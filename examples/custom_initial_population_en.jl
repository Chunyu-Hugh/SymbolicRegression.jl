"""
Example: How to Use Custom Initial Population

This example demonstrates how to create a custom initial population and pass it to the equation_search function.

⚠️ Important Note:
If you have modified the source code of SymbolicRegression.jl, you need to make Julia use the local development version.
Before running this script, execute the following in Julia REPL:

    using Pkg
    Pkg.develop(path="C:/Users/cs_chu034/download/projects/SR_LLM/SymbolicRegression.jl")
    # Or use a relative path (from project root)
    # Pkg.develop(path="./SymbolicRegression.jl")

Then reload the module:
    using SymbolicRegression

See examples/README_DEVELOPMENT.md for more information.
"""

# Ensure using local development version
# If you encounter dependency conflicts (e.g., LibraryAugmentedSymbolicRegression), you can use the following methods:

# Method 1: Remove conflicting packages (recommended)
# using Pkg
# Pkg.rm("LibraryAugmentedSymbolicRegression")
# Pkg.develop(path=joinpath(@__DIR__, ".."))
# using SymbolicRegression

# Method 2: Create a new environment (recommended for development)
# using Pkg
# Pkg.activate(".")
# Pkg.develop(path=joinpath(@__DIR__, ".."))
# Pkg.instantiate()
# using SymbolicRegression

# Method 3: Direct use (if dependency conflicts are resolved)
# Note: If you encounter "no method matching" errors, it means you're still using the installed package version
# You need to execute method 1 or 2 first, or restart Julia and reload

using SymbolicRegression
using DynamicExpressions: parse_expression

# Verify if using local version (optional)
try
    sr_path = pathof(SymbolicRegression)
    local_path = joinpath(@__DIR__, "..", "src", "SymbolicRegression.jl")
    if occursin(abspath(local_path), sr_path)
        println("✓ Using local development version: ", sr_path)
    else
        @warn "⚠ May still be using installed package version: ", sr_path
        @warn "   If you encounter 'no method matching' errors, use method 1 or 2 to load local version"
    end
catch
    # Ignore errors
end

# 1. Prepare data
# Dataset contains 5 features, target generated by the following formula:
# y = 2 * cos(x4) + x1^2 - 2 + noise
X = randn(Float64, 5, 100)
y = 2 .* cos.(X[4, :]) .+ X[1, :].^2 .- 2
y = y .+ randn(100) .* 1e-3

# 2. Set options
# Note: Need to use safe_pow instead of ^, because SymbolicRegression uses safe_pow for power operations
using SymbolicRegression: safe_pow
options = Options(;
    binary_operators=[+, *, -, /, safe_pow],  # Use safe_pow instead of ^
    unary_operators=[cos],
    population_size=20,  # Population size
    maxsize=10,
)

# 3. Create dataset
dataset = Dataset(X, y)

# Method 1: Create custom population from string expressions
# println("=" ^ 80)
# println("Method 1: Create custom population from string expressions")
# println("=" ^ 80)
#
# # Create some custom expressions
# # Note: parse_expression may not directly parse ^ in strings, so use simple expressions here
# # If power operations are needed, you can manually modify the tree structure after creating PopMember, or use other methods
custom_expressions = [
    "x1 + x2",
    "x1 + 2.0 * cos(x4)",
    "x1 - x3 + x5",
    "safe_pow(x1, 2) + x2",
    "x1 * x2 + x3",
    "x1 * x4 + x5",
    "x1 * x2 * x3",
    "(x1 + x2) * x4",
    "(x1 + x2 + x3) / (x4 + 1.0)",
    "x1 + x2 + x3 + x4 + x5",
    "(x1 - x2) * (x3 - x4)",
    "x1 / (1.0 + safe_pow(x2, 2)) + x5",
    "x1 + safe_pow(x3, 2) - 2.0",
    "2.0 * cos(x4) + x1",
    "2.0 * cos(x4) + safe_pow(x1, 2)",
    "(x1 + 0.5 * x5) * cos(x4)",
    "(x1 - x2) / (x5 + 1.0)",
    "(x1 + x2) * (x3 + x4)",
    "x1 + x2 * x5 + cos(x4)",
    "safe_pow(x1 + x2, 2) - x3 + cos(x4)",
]

#=
println("=" ^ 80)
println("Method 1: Create custom population from string expressions")
println("=" ^ 80)

# Convert string expressions to PopMember objects
# Use guesses parameter to create correctly typed members (recommended method)
println("Creating custom members using guesses parameter...")
temp_hof = equation_search(
    X, y;
    options=options,
    guesses=custom_expressions,
    niterations=0,  # Don't search, only create guesses
    parallelism=:serial,
)

# Extract custom members from HallOfFame
# Note: guesses will be parsed and added to HallOfFame, but may not be in the first few positions
# We need to find all existing members and extract those with matching complexity
custom_members_from_guesses = typeof(temp_hof.members[1])[]
for size in 1:options.maxsize
    if temp_hof.exists[size]
        # Check if this member comes from our guesses (by checking if complexity is reasonable)
        # Actually, guesses will be added to seed_members and added through migration
        # Here we simply extract all existing members
        push!(custom_members_from_guesses, temp_hof.members[size])
        if size <= length(custom_expressions)
            println("✓ Created member from guesses (complexity=$size): $(custom_expressions[size])")
        end
    end
end

# Only keep the first few (matching guesses count)
if length(custom_members_from_guesses) > length(custom_expressions)
    custom_members_from_guesses = custom_members_from_guesses[1:min(length(custom_expressions), length(custom_members_from_guesses))]
end

# Create complete population: custom members + random members
if length(custom_members_from_guesses) > 0
    # First create a complete random population
    random_pop = Population(
        dataset;
        population_size=options.population_size,
        nlength=3,
        options=options,
        nfeatures=size(X, 1),
    )
    # Use random population type as baseline
    custom_members = typeof(random_pop.members[1])[]
    
    # Add custom members (recreate to ensure type matching)
    for member in custom_members_from_guesses
        try
            # Try to add directly
            push!(custom_members, member)
        catch
            # If type mismatch, recreate
            new_member = PopMember(
                dataset,
                member.tree.tree,  # Use original tree nodes
                options;
                deterministic=options.deterministic,
            )
            push!(custom_members, new_member)
        end
    end
    
    # Add random members
    for i in 1:(options.population_size - length(custom_members))
        push!(custom_members, random_pop.members[i])
    end
    
    println("Successfully created $(length(custom_members_from_guesses)) custom members, supplemented with $(options.population_size - length(custom_members_from_guesses)) random members")
else
    println("Warning: Unable to create any members from guesses, using completely random population")
    custom_members = Population(
        dataset;
        population_size=options.population_size,
        nlength=3,
        options=options,
        nfeatures=size(X, 1),
    ).members
end

# Create custom population
custom_population = Population(custom_members)
println("\nCustom population size: $(length(custom_population.members))")

# Use custom population for search
println("\nStarting search with custom population...")
hall_of_fame = equation_search(
    X, y;
    options=options,
    initial_population=custom_population,
    parallelism=:serial,
    niterations=20,
)

# Display results
dominating = calculate_pareto_frontier(hall_of_fame)
println("\nFound optimal expressions:")
for member in dominating
    complexity = compute_complexity(member, options)
    loss = member.loss
    string = string_tree(member.tree, options)
    println("Complexity: $complexity, Loss: $loss, Expression: $string")
end
=#

#=
println("\n" * "=" ^ 80)
println("Method 2: Create custom population from existing search results")
println("=" ^ 80)

# First perform a search
println("Performing first search...")
hof1 = equation_search(X, y; options=options, niterations=10, parallelism=:serial)

# Extract some members from first search results
# First create a random population to determine correct type
temp_pop2 = Population(
    dataset;
    population_size=1,
    nlength=3,
    options=options,
    nfeatures=size(X, 1),
)
best_members = typeof(temp_pop2.members[1])[]

# Extract members from HallOfFame
# Note: HallOfFame returned by equation_search has been processed through embed_metadata
# But type may differ from members created by Population, so we need to recreate members to ensure type matching
for size in 1:min(5, options.maxsize)
    if hof1.exists[size]
        member = hof1.members[size]
        # Recreate PopMember to ensure type matching
        # Use existing member's tree nodes, recreate through create_expression to ensure correct type
        new_member = PopMember(
            dataset,
            member.tree.tree,  # Use original tree nodes
            options;
            deterministic=options.deterministic,
        )
        push!(best_members, new_member)
        println("✓ Extracted member (complexity=$size): $(string_tree(new_member.tree, options))")
    end
end

# If no members extracted, create a random population
if isempty(best_members)
    println("Warning: Unable to extract members from HallOfFame, using random population")
    best_members = Population(
        dataset;
        population_size=options.population_size,
        nlength=3,
        options=options,
        nfeatures=size(X, 1),
    ).members
end

# Supplement random members
if length(best_members) < options.population_size
    random_pop2 = Population(
        dataset;
        population_size=options.population_size - length(best_members),
        nlength=3,
        options=options,
        nfeatures=size(X, 1),
    )
    # Use vcat instead of append! to avoid type conversion issues
    best_members = vcat(best_members, random_pop2.members)
end

# Create new custom population
custom_population2 = Population(best_members)
println("\nUsing improved population for second search...")
hof2 = equation_search(
    X, y;
    options=options,
    initial_population=custom_population2,
    parallelism=:serial,
    niterations=20,
)

# Display results
dominating2 = calculate_pareto_frontier(hof2)
println("\nOptimal expressions found in second search:")
for member in dominating2
    complexity = compute_complexity(member, options)
    loss = member.loss
    string = string_tree(member.tree, options)
    println("Complexity: $complexity, Loss: $loss, Expression: $string")
end
=#

# Method 3: Manually create PopMember objects
println("\n" * "=" ^ 80)
println("Method 3: Manually create PopMember objects")
println("=" ^ 80)

# Use gen_random_tree to create some random trees
using SymbolicRegression: gen_random_tree

# First create a temporary population to determine correct type
temp_pop3 = Population(
    dataset;
    population_size=1,
    nlength=3,
    options=options,
    nfeatures=size(X, 1),
)
manual_members = typeof(temp_pop3.members[1])[]

# Check if expression contains feature variables (avoid generating pure constant expressions)
contains_feature(tree) = any(tree) do node
    node.degree == 0 && !node.constant
end

# Generate members with variables
while length(manual_members) < options.population_size
    tree = gen_random_tree(3, options, size(X, 1), Float64)
    contains_feature(tree) || continue
    member = PopMember(dataset, tree, options; deterministic=options.deterministic)
    push!(manual_members, member)
end

custom_population3 = Population(manual_members)
println("Manually created population size: $(length(custom_population3.members))")

# Verification: Print first few members in initial population for later comparison
println("\nFirst 5 members in initial population (for verification of usage):")
initial_member_strings = String[]
for (idx, member) in enumerate(custom_population3.members[1:min(5, length(custom_population3.members))])
    member_str = string_tree(member.tree, options)
    complexity = compute_complexity(member, options)
    println("  [$idx] Complexity=$complexity, Expression: $member_str")
    push!(initial_member_strings, member_str)
end

# Verify population size matches
if length(custom_population3.members) != options.population_size
    @warn "⚠️  Warning: Custom population size ($(length(custom_population3.members))) does not match options.population_size ($(options.population_size))!"
    @warn "   System will fall back to random population, custom population will not be used!"
else
    println("✓ Population size matches ($(length(custom_population3.members)) == $(options.population_size)), custom population should be used")
end

println("\nStarting search with manual population...")
hof3 = equation_search(
    X, y;
    options=options,
    initial_population=custom_population3,
    parallelism=:serial,
    niterations=20,
)

dominating3 = calculate_pareto_frontier(hof3)
println("\nOptimal expressions found in third search:")
for member in dominating3
    complexity = compute_complexity(member, options)
    loss = member.loss
    string = string_tree(member.tree, options)
    println("Complexity: $complexity, Loss: $loss, Expression: $string")
end

# Verification notes
println("\n" * "=" ^ 80)
println("Verification Notes:")
println("=" ^ 80)
println("""
Based on analysis of SymbolicRegression.jl source code:

1. Custom population usage flow:
   - equation_search function checks initial_population parameter at lines 822-873
   - If population size matches, custom population will be processed with strip_metadata
   - Loss will be recalculated for each member (on new dataset)
   - Custom population will be passed to evolution loop through @sr_spawner
   - In _dispatch_s_r_cycle, custom population is passed as in_pop to s_r_cycle for evolution

2. Verification methods:
   - Check if population size matches (printed above)
   - If size doesn't match, you'll see warning messages, system will fall back to random population
   - If size matches, custom population will be used, but members will be modified/replaced during evolution

3. Notes:
   - Even if custom population is used, evolution process will change population through mutation, crossover, etc.
   - Initial members may be quickly replaced by better individuals
   - To confirm if custom population is really used, you can:
     a) Check for warning messages (if warnings exist, it wasn't used)
     b) Set verbosity > 0 to see detailed logs
     c) Use niterations=0 to only initialize population without evolution, then check population content

4. Current status:
   - Population size: $(length(custom_population3.members))
   - options.population_size: $(options.population_size)
   - Match status: $(length(custom_population3.members) == options.population_size ? "✓ Matched" : "✗ Not matched")
""")

println("\n" * "=" ^ 80)
println("Method 3 Extension: Continue search with high complexity members")
println("=" ^ 80)

complexity_threshold = 7
selected_members = typeof(custom_population3.members[1])[]
for size in reverse(1:options.maxsize)
    if hof3.exists[size] && size >= complexity_threshold
        member = hof3.members[size]
        new_member = PopMember(
            dataset,
            member.tree.tree,
            options;
            deterministic=options.deterministic,
        )
        push!(selected_members, new_member)
        println("✓ Selected member (complexity=$size): $(string_tree(new_member.tree, options))")
    end
end

if isempty(selected_members)
    println("Warning: No members found meeting complexity threshold, using first few members from method 3 results")
    for size in reverse(1:options.maxsize)
        if hof3.exists[size]
            member = hof3.members[size]
            new_member = PopMember(
                dataset,
                member.tree.tree,
                options;
                deterministic=options.deterministic,
            )
            push!(selected_members, new_member)
        end
        length(selected_members) >= min(options.population_size, 5) && break
    end
end

while length(selected_members) < options.population_size
    idx = (length(selected_members) % length(manual_members)) + 1
    backup_member = manual_members[idx]
    push!(
        selected_members,
        PopMember(
            dataset,
            backup_member.tree.tree,
            options;
            deterministic=options.deterministic,
        ),
    )
end

custom_population4 = Population(selected_members[1:options.population_size])
println("High complexity population size: $(length(custom_population4.members))")

println("Searching again with high complexity members...")
hof4 = equation_search(
    X, y;
    options=options,
    initial_population=custom_population4,
    parallelism=:serial,
    niterations=20,
)

dominating4 = calculate_pareto_frontier(hof4)
println("\nOptimal expressions from search again:")
for member in dominating4
    complexity = compute_complexity(member, options)
    loss = member.loss
    string = string_tree(member.tree, options)
    println("Complexity: $complexity, Loss: $loss, Expression: $string")
end

println("\n" * "=" ^ 80)
println("Summary:")
println("=" ^ 80)
println("""
You can create custom initial populations through the following methods:

1. From string expressions: Use parse_expression to parse strings, then create PopMember
2. From existing search results: Extract members from HallOfFame
3. Manual creation: Use gen_random_tree or other methods to create expression trees

Notes:
- Population size must match options.population_size
- If population size doesn't match, system will fall back to random population
- Members in custom population will have loss recalculated on new dataset
- Can be used in combination with guesses parameter, guesses will be added to population through migration mechanism
""")

